<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[HTML5全局属性]]></title>
      <url>http://blog.zhiyuanep.net/2017/07/02/HTML5%E5%85%A8%E5%B1%80%E5%B1%9E%E6%80%A7/</url>
      <content type="html"><![CDATA[<p>全局属性是所有 HTML 元素共有的属性；它们可以用于所有元素，尽管属性可能对某些元素没有影响。</p>
<h3 id="accesskey"><a href="#accesskey" class="headerlink" title="accesskey"></a>accesskey</h3><p>这个属性提供了一种使用快捷键访问当前元素的途径。它是用一个字符（单个 Unicode code）列表的独立规范构成。浏览器应使用键盘的第一布局。</p>
<h3 id="class"><a href="#class" class="headerlink" title="class"></a>class</h3><p>class 属性允许 css 和 JavaScript 通过 class 选择器或者类似以下的 DOM 方法来选择和访问 Element：</p>
<pre><code>document.getElementsByClassName()
</code></pre><p><strong>使用说明</strong>：尽管规范没有将 class 的名字定为必须的，但是开发者会使用一个能描述 element 语义化用途的名字，而不会使用一个描述他外观的名字。语义化的名字仍然有意义即使页面的表现形式改变了。</p>
<h3 id="contenteditable"><a href="#contenteditable" class="headerlink" title="contenteditable"></a>contenteditable</h3><p>这个<strong>可枚举</strong>的属性表示该 element 可以被用户编辑。如果是这样，浏览器会修改 widget 让它允许编辑。其值为 <code>true</code> 或 <code>false</code>。</p>
<p>如果这个属性没有被设置，它的默认值会继承其父 element 的值。</p>
<p><strong>使用说明</strong>：该属性是一个可枚举的属性，而不是一个布尔属性。这意味着 <code>true</code>、<code>false</code>或空字符串的显式使用是强制的。这样的简写 <code>&lt;label contenteditable&gt;Example Label&lt;/label&gt;</code> 是不允许的。正确的使用方式是：<code>&lt;label contenteditable=&quot;true&quot;&gt;Example Label&lt;/label&gt;</code>.</p>
<h3 id="contextmenu"><a href="#contextmenu" class="headerlink" title="contextmenu"></a>contextmenu</h3><p>一个 context menu 是一个菜单，出现在用户的交互里，比如一次右击。 HTML5 允许我们自定义这个菜单。</p>
<h3 id="data"><a href="#data" class="headerlink" title="data-*"></a>data-*</h3><p>这类属性被称为自定义属性，允许 HTML 与和它对应 DOM 表现形式之间的专有信息交换，这或许对 script 来说有用。<code>HTMLElement.dataset</code> 属性提供了访问它们的权限。</p>
<p>命名规则：</p>
<ul>
<li>不能以 xml 开头，除此之外其它斜体情形都可以使用这三个字母；</li>
<li>名字不能含有分号；</li>
<li>名字不能含有大写字母。</li>
</ul>
<p>注意：<code>HTMLElement.dataset</code>是一个 StringMap，一个名叫 <code>data-test-value</code>的自定义属性可以通过 <code>HTMLElement.dataset.testValue</code> 来访问。属性的名字中的中线被挨着它字母的大写字母代替了（驼峰命名）。</p>
<h3 id="dir"><a href="#dir" class="headerlink" title="dir"></a>dir</h3><p>这个<strong>可枚举</strong>属性表明 element 的文本方向，可以取以下的值：</p>
<ul>
<li><code>ltr</code>，适用于从左到右的语言；</li>
<li><code>rtl</code>，适用于从右到左的语言；</li>
<li><code>auto</code>，由代理决定。用一个最基础的算法来解析 element 中的字符，如果发现有一个字符具有强的方向性，那么就把这个方向作为整个 element 的方向。</li>
</ul>
<p><strong>使用说明</strong>：</p>
<ul>
<li>这个属性在 <code>&lt;bdo&gt;</code> 元素中强制要求使用，它在里边有不同的语法含义。</li>
<li><code>&lt;bdi&gt;</code> 元素不继承父元素的该属性。如果不设置，它的值就是 <code>auto</code>。</li>
<li>这个属性能够被 css 属性 <code>direction</code> 和 <code>unicode-bidi</code> 覆盖。</li>
<li>因为文本的方向与内容本身有关，和它的表现没关系，所以推荐开发者尽可能使用这个属性来避免在 css 属性中使用。这样的话，即使浏览器不支持 css 或者 css 被解除，它还是会正确显示。</li>
<li><code>auto</code>值应该用到不明方向的数据中，就像用户输入的数据，它最终会保存到数据中去。</li>
</ul>
<h3 id="draggable"><a href="#draggable" class="headerlink" title="draggable"></a>draggable</h3><p>这个<strong>可枚举</strong>的属性决定一个 element 是否能够被拖动，可使用以下的值：</p>
<ul>
<li><code>true</code>，表示该 element 可以被拖动。</li>
<li><code>false</code>，表示该 element 不可以被拖动。</li>
<li><code>auto</code>，默认值，表示它的行为由浏览器定义。</li>
</ul>
<p><strong>使用说明</strong>：</p>
<ul>
<li>该属性是一个可枚举属性，不是布尔属性，其值不能够被简写。</li>
<li>默认情况下，只有被选中的文本、图像、链接能够被拖动。对于其它 element 而言，为也让拖拽机制能够正常工作，<code>ondragstart</code> 必须被设置。</li>
</ul>
<h3 id="dropzone（未实现）"><a href="#dropzone（未实现）" class="headerlink" title="dropzone（未实现）"></a>dropzone（未实现）</h3><p>这个<strong>可枚举</strong>属性决定丢到一个 element 上的内容类型，可使用的值如下：</p>
<ul>
<li><code>copy</code>，表示丢放时会创建一个被拖拽 element 的副本；</li>
<li><code>move</code>，表示被拖拽的 element 被移动到这个新位置；</li>
<li><code>link</code>，将会给拖拽的数据创建一个链接。</li>
</ul>
<h3 id="hidden"><a href="#hidden" class="headerlink" title="hidden"></a>hidden</h3><p>这个<strong>布尔</strong>属性表示 element 被隐藏，浏览器不会渲染该元素。</p>
<h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>这个属性是 element 唯一的标识，它在整个 document 里应该是唯一的。当需要链接、执行脚本、控制样式时，可以用它来定位识别元素。</p>
<h3 id="lang"><a href="#lang" class="headerlink" title="lang"></a>lang</h3><p>这个属性用于定义 element 的语言。不管这个 element 能不能被编辑，都应该写上这个属性。</p>
<p>如果属性的内容是空字符串，那么语言就会被设置为 unknown；如果标签的内容是无效的，它就会被设置为 invalid。</p>
<h3 id="spellcheck"><a href="#spellcheck" class="headerlink" title="spellcheck"></a>spellcheck</h3><p>这个<strong>可枚举</strong>属性定义 element 是否检查拼写错误。它的值可以是以下：</p>
<ul>
<li><code>true</code>,表示如果可能的话， element 应该被检查拼写错误；</li>
<li><code>false</code>，表示 element不应该检查拼写错误。<br>×　默认值可能是浏览器定义的，也可能由父元素决定。</li>
</ul>
<p><strong>使用说明</strong>：</p>
<ul>
<li>这个属性是可枚举的，不是一个布尔属性，值不可以简写；</li>
<li>对于浏览器来说，这个属性只是一个提示，浏览器不一定会去检查拼写错误。通常不可编辑的 element 是不检查拼写错误的。</li>
</ul>
<h3 id="style"><a href="#style" class="headerlink" title="style"></a>style</h3><p>这个属性包含 css 样式声明，被应用到元素上。注意推荐将它定义在其它文件里。这个属性和 <code>&lt;style&gt;</code> 元素一样，主要的目的是快速编写样式，用来测试想要的效果。</p>
<h3 id="tabindex"><a href="#tabindex" class="headerlink" title="tabindex"></a>tabindex</h3><p>这个整数类型的属性决定 element 是否要以获得焦点，如果它参与到排序的键盘导航，就可以定位它。它可能需要以下几种值：</p>
<ul>
<li>负数意味着该 element 不可以获得焦点，也不可以通过排序的键盘导航到达；</li>
<li>0 意味着 element 可以通过排序的键盘导航到达，但是相对顺序取决于平台惯例；</li>
<li>一个正数意味着可以通过排序的键盘导航获得焦点并到达。相对顺序去决议该属性的值，按照 tabindex 的增值排序。如果几个 element 有相同的 tabindex,他们的相对顺序取决于他们在 document 中的位置。</li>
</ul>
<p>在排序的键盘导航单上，如果一个元素的 tabindex 的值是一个0或者无效值或没有该属性，那么它应该被放在值是正数的element 后边。</p>
<h3 id="title"><a href="#title" class="headerlink" title="title"></a>title</h3><p>这个属性包含的是文本信息，该信息代表 element 自己包含的内容的公告。这样的信息不是必要的，但是作为一个提示用户的工具，一般会有以下几个用法：</p>
<ul>
<li>链接：关于被链接文档的一个标题或一段描述；</li>
<li>和图片类似的媒体元素：一段描述或相关的可信度；</li>
<li>段落：脚注活评论；</li>
<li>引用：关于作者等一些信息。</li>
</ul>
<p>如果这个属性不存在或被清除了，则意味着离它最近的祖先元素的 title 和它相关（能够相应地成为这个元素的提示工具）。如果这个属性是空字符串，则表示离它最近的父元素的 title 和它没关系（不能作为这个元素的提示工具）。</p>
<p><code>&lt;link&gt;</code>、<code>&lt;abbr&gt;</code>和 <code>&lt;input&gt;</code>的 title 属性可以包含额外的语义信息。</p>
<p>title 可能包含多行信息，通过插入换行符。</p>
<h3 id="translate"><a href="#translate" class="headerlink" title="translate"></a>translate</h3><p>这是一个可枚举属性，用于确定当页面进行本地化时，元素的属性以及元素的文本子节点中的内容是否要进行翻译。其可取的值如下 ：</p>
<ul>
<li>空字符串或者 <code>yes</code>，表示这个元素相关的内容将会被翻译；</li>
<li><code>no</code>，表示这个元素相关的内容不会被翻译。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> HTML5 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> HTML5 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://blog.zhiyuanep.net/2017/07/01/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Git 常用命令快速预览]]></title>
      <url>http://blog.zhiyuanep.net/2017/06/30/Git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%BF%AB%E9%80%9F%E9%A2%84%E8%A7%88/</url>
      <content type="html"><![CDATA[<p>本文摘录自 <a href="https://services.github.com/on-demand/downloads/github-git-cheat-sheet.pdf" target="_blank" rel="external">https://services.github.com/on-demand/downloads/github-git-cheat-sheet.pdf</a> 。</p>
<h2 id="配置工具"><a href="#配置工具" class="headerlink" title="配置工具"></a>配置工具</h2><p>为所有本地仓库配置用户信息。</p>
<ul>
<li><pre><code>$ git config --global user.name &quot;[name]&quot;
</code></pre><p> 设置提交时的用户名称。</p>
</li>
<li><pre><code>$ git config --global user.email &quot;[email address]&quot;
</code></pre><p> 设置提交时的邮箱地址。</p>
</li>
<li><pre><code>$ git config --global color.ui auto
</code></pre><p> 为 Git 命令行输出开启颜色强调。</p>
</li>
</ul>
<h2 id="创建代码仓库"><a href="#创建代码仓库" class="headerlink" title="创建代码仓库"></a>创建代码仓库</h2><p>新建或者从指定 URL 导入仓库。</p>
<ul>
<li><pre><code>$ git init [project-name]
</code></pre><p> 新建指定名称的本地仓库。</p>
</li>
<li><pre><code>$ git clone [url]
</code></pre><p> 从指定 URL 导入代码仓库，包含该仓库的所有版本信息。</p>
</li>
</ul>
<h2 id="提交修改"><a href="#提交修改" class="headerlink" title="提交修改"></a>提交修改</h2><p>预览并提交修改。</p>
<ul>
<li><pre><code>$ git status
</code></pre><p> 列出工作区所有新建或被修改的文件。</p>
</li>
<li><pre><code>$ git diff
</code></pre><p> 列出工作区中所有未被暂存的修改。</p>
</li>
<li><pre><code>$ git add [file]
</code></pre><p> 将指定文件的当前版本加入暂存区，准备被提交。</p>
</li>
<li><pre><code>git diff --staged
</code></pre><p> 比较暂存区的文件与仓库最新版本的差异。</p>
</li>
<li><pre><code>git reset [file]
</code></pre><p> 将指定文件从暂存区移除，但保留在工作区被修改的内容。</p>
</li>
<li><pre><code>git commit -m &quot;[descriptive message]&quot;
</code></pre><p> 将文件快照永久保存到仓库。</p>
</li>
</ul>
<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><ul>
<li><pre><code>git branch
</code></pre><p>  列出当前仓库的所有分支。</p>
</li>
<li><pre><code>git branch [branch-name]
</code></pre><p> 创建新的分支。</p>
</li>
<li><pre><code>git checkout [branch-name]
</code></pre><p> 切换到指定分支，并更新工作目录。</p>
</li>
<li><pre><code>git merge [branch]
</code></pre><p> 将指定分支的提交历史合并到当前分支。</p>
</li>
<li><pre><code>git branch -d [branch-name]
</code></pre><p> 删除指定分支。</p>
</li>
</ul>
<h2 id="重构文件名"><a href="#重构文件名" class="headerlink" title="重构文件名"></a>重构文件名</h2><p>移动或删除已经被版本追踪的文件。</p>
<ul>
<li><pre><code>git rm [file]
</code></pre><p> 将指定文件从工作区删除，并将该修改提交到暂存区。</p>
</li>
<li><pre><code>git rm --cached [file]
</code></pre><p> 将指定文件从版本控制中移除，保留工作区的副本。</p>
</li>
<li><pre><code>git mv [src] [dest]
</code></pre><p> 更改文件名，并提交到暂存区。</p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Git </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Git学习笔记]]></title>
      <url>http://blog.zhiyuanep.net/2017/04/19/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>摘录于《Git Pro》。原文地址:<a href="https://git-scm.com/book/zh/v2/" target="_blank" rel="external">https://git-scm.com/book/zh/v2/</a></p>
<h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><h3 id="关于版本控制"><a href="#关于版本控制" class="headerlink" title="关于版本控制"></a>关于版本控制</h3><h4 id="什么是“版本控制”？"><a href="#什么是“版本控制”？" class="headerlink" title="什么是“版本控制”？"></a>什么是“版本控制”？</h4><p>版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。</p>
<h4 id="版本控制系统-VCS-的演进"><a href="#版本控制系统-VCS-的演进" class="headerlink" title="版本控制系统(VCS)的演进"></a>版本控制系统(VCS)的演进</h4><p>本地版本控制系统 -&gt; 集中化的版本控制系统 -&gt; 分布式版本控制系统。</p>
<h4 id="本地版本控制系统"><a href="#本地版本控制系统" class="headerlink" title="本地版本控制系统"></a>本地版本控制系统</h4><p>大多数都是采用某种简单的数据库来记录文件的历次更新的差异。其中最流行的是RCS，它的工作原理是在硬盘上保存补丁集（文件修订前后的变化）；通过应用所有补丁，可以重新计算出各个版本的文件内容。</p>
<img src="/2017/04/19/Git学习笔记/local.png" alt="本地版本控制系统" title="本地版本控制系统">
<h4 id="集中化的版本控制系统-CVCS"><a href="#集中化的版本控制系统-CVCS" class="headerlink" title="集中化的版本控制系统(CVCS)"></a>集中化的版本控制系统(CVCS)</h4><p>是为了让不同系统上的开发者协同工作而生。些类系统包括 CVS、Subversion(SVN) 以及 Perforce 等。都有一个单一的集中管理的服务器，保存所有文件的修订版本。客户端需要连接到该服务器才能取出最新的文件或者提交更新。</p>
<img src="/2017/04/19/Git学习笔记/centralized.png" alt="集中化版本控制系统" title="集中化版本控制系统">
<p>相比于本地 VCS 来说，可以在一定程度上看到项目中其它人的工作成果。而管理员也可以轻松掌控每个开发者的权限。其显而易见的缺点是中央服务器的单点故障。如果服务器宕机，所有人都无法更新和提交。如果服务器磁盘发生损坏，则会丢失项目整个变更历史，只剩下每个人各自机器上保留的单独快照。本地 VCS 也存在该问题。此外，客户端必须与服务器联网才能更新和提交。</p>
<h4 id="分布式版本控制系统"><a href="#分布式版本控制系统" class="headerlink" title="分布式版本控制系统"></a>分布式版本控制系统</h4><p>分布式版本控制系统 (DVCS) 是为了解决上述问题而生。这类系统包括 Git、Mercurial、Bazaar 以及 Darcs 等。客户端不再只是提取最新版本的文件快照，而是把代码仓库完整地镜像下来。任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。</p>
<img src="/2017/04/19/Git学习笔记/distributed.png" alt="分布式版本控制系统" title="分布式版本控制系统">
<p>更进一步，许多这类系统都可以指定和若干不同的远端代码仓库进行交互。籍此，你就可以在同一个项目中，分别和不同工作小组的人相互协作。</p>
<h3 id="Git-的思想和基本工作原理"><a href="#Git-的思想和基本工作原理" class="headerlink" title="Git 的思想和基本工作原理"></a>Git 的思想和基本工作原理</h3><p>注意与 Subversion 等其它版本管理系统的区别。</p>
<h4 id="直接记录快照，而非差异比较"><a href="#直接记录快照，而非差异比较" class="headerlink" title="直接记录快照，而非差异比较"></a>直接记录快照，而非差异比较</h4><p>Git 的这种对待数据的方法是与其它版本控制系统（包括 Subversion 和近似工具）的主要差别。</p>
<p>其它大部分系统以文件变更列表的方式存储信息，它们将保存的信息看作是一组<strong>基本文件</strong>和每个文件随着时间逐步累积的<strong>差异</strong>。</p>
<img src="/2017/04/19/Git学习笔记/deltas.png" alt="存储每个文件及与初始版本的差异" title="存储每个文件及与初始版本的差异">
<p>Git 将数据看作是对小型文件系统的一组快照。每次提交更新或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。Git 对待数据更像是一个 <strong>快照流</strong>。</p>
<img src="/2017/04/19/Git学习笔记/snapshots.png" alt="存储项目随时间改变的快照" title="存储项目随时间改变的快照">
<h4 id="近乎所有操作都是本地执行"><a href="#近乎所有操作都是本地执行" class="headerlink" title="近乎所有操作都是本地执行"></a>近乎所有操作都是本地执行</h4><p>Git 中绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。比如你要浏览项目的历史，因为你的本地磁盘保存的是完整的代码库，你可以随时随地查看项目历史而无需与服务器联网，这一点在以往的集中式版本控制系统无法做到。如果你需要提交修改，在不联网的情况下，Git 允许你先提交到本地仓库，待联网后再推送到远程仓库。而而集中式版本控制系统（比如 Subversion）必须与服务器处于联网状态才能够提交修改。</p>
<h4 id="Git-保证完整性"><a href="#Git-保证完整性" class="headerlink" title="Git 保证完整性"></a>Git 保证完整性</h4><p>Git 中所有数据在存储前都计算校验和，然后以校验和来引用。 这意味着不可能在 Git 不知情时更改任何文件内容或目录内容。 这个功能建构在 Git 底层，是构成 Git 哲学不可或缺的部分。 若你在传送过程中丢失信息或损坏文件，Git 就能发现。</p>
<h4 id="Git-一般只添加数据"><a href="#Git-一般只添加数据" class="headerlink" title="Git 一般只添加数据"></a>Git 一般只添加数据</h4><p>你执行的 Git 操作，几乎都是只往 Git 数据库中增加数据。很难让 Git 执行任何不可逆操作。或者让它以任何方式清除数据。未提交更新时有可能丢失或弄乱修改的内容，但是一旦提交快照到 Git 中，就很难再丢失数据。</p>
<h4 id="三种状态"><a href="#三种状态" class="headerlink" title="三种状态"></a>三种状态</h4><p>Git 有三种状态，你的文件可能处于其中之一：已修改（modified）、已暂存（staged）、已提交（committed）。已修改表示修改了文件，但还没保存到数据库中；已暂存表示对一个已修改文件的当前版本作了标记，使之包含在下次提交的快照中；已提交表示数据已经安全保存在本地数据库中。</p>
<p>由三种状态引入 Git 项目的三个工作区域的概念：工作目录、暂存区域、Git 仓库。</p>
<img src="/2017/04/19/Git学习笔记/areas.png" alt="工作目录、暂存区域以及 Git 仓库" title="工作目录、暂存区域以及 Git 仓库">
<p>工作目录：是对项目的某个版本独立提取出来的内容。这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。<br>暂存区域：是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。<br>Git 仓库：是 Git 用来保存项目的元数据和对象数据库的地方。这是 Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。</p>
<h4 id="基本的-Git-工作流程"><a href="#基本的-Git-工作流程" class="headerlink" title="基本的 Git 工作流程"></a>基本的 Git 工作流程</h4><ol>
<li>在工作目录中修改文件；</li>
<li>暂存文件，将文件的快照放入暂存区域。</li>
<li>提交更新，找到暂存区域的文件，将快照永久性存到 Git 仓库目录。</li>
</ol>
<p>如果自上次取出后，作了修改但还没有放到暂存区域，就是已修改状态；如果作为修改并已放入暂存区域，就属于已暂存状态；如果 Git 目录中保存着特定版本文件，就属于已提交状态。</p>
<h3 id="初次运行-Git-前的配置"><a href="#初次运行-Git-前的配置" class="headerlink" title="初次运行 Git 前的配置"></a>初次运行 Git 前的配置</h3><p>Git 自带一个 <code>git config</code> 的工具来帮助设置控制 Git 外观和行为的配置变量。这些变量配置文件在三个地方：</p>
<ol>
<li><code>/etc/gitconfig</code>：包含系统上每一个用户及他们仓库的通用配置。如果使用带有 <code>--system</code> 选项的 <code>git config</code> 时，它会从此文件读写配置变量。</li>
<li><code>~/.gitconfig</code>或 <code>~/.config/git/config</code>文件：只针对当前用户。可以传递 <code>--global</code> 选项让 Git 读写些文件。</li>
<li>当前使用仓库的 Git 目录中的 <code>config</code> 文件（就是<code>.git/config</code>）：针对该仓库。</li>
</ol>
<p>每个具体级别覆盖上一级别的配置。</p>
<h4 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h4><p>设置用户名称和邮件地址，每一个 Git 的提交都会使用这些信息，并且会写入到每一次提交中，不可更改：</p>
<pre><code>$ git config --global user.name &quot;John Doe&quot;
$ git config --global user.email &quot;johndoe@example.com&quot;
</code></pre><p>注意：如果使用了<code>--global</code>选项，那么对于该用户上的所有项目都默认使用这些信息。如果想针对特定项目使用不同的用户名称与邮件地址，可以在该项目目录下运行没有<code>--global</code>选项的命令来配置。</p>
<h4 id="文本编辑器"><a href="#文本编辑器" class="headerlink" title="文本编辑器"></a>文本编辑器</h4><p>当 Git 需要你输入信息时会调用它。如果未配置，Git 会使用操作系统默认的文本编辑器。如果想使用不同的文本编辑器，可以这样做：</p>
<pre><code>$ git config --global core.editor emacs
</code></pre><h4 id="检查配置信息"><a href="#检查配置信息" class="headerlink" title="检查配置信息"></a>检查配置信息</h4><p>可以使用 <code>git config --list</code>命令来列出所有 Git 当时能找到的配置。</p>
<p>可能会看到重复的变量名，因为 Git 会从不同的文件中读取同一个配置。这种情况下，Git 会使用它找到的每一个变量的最后一个配置。</p>
<p>可以通过输入<code>git config &lt;key&gt;</code>来检查特定配置项。</p>
<pre><code>$ git config user.name
John Doe
</code></pre><h3 id="获取帮助"><a href="#获取帮助" class="headerlink" title="获取帮助"></a>获取帮助</h3><p>有三种方法可以找到 Git 命令的使用手册：</p>
<pre><code>$ git help &lt;verb&gt;
$ git &lt;verb&gt; --help
$ man git-&lt;verb&gt;
</code></pre><h2 id="Git-基础"><a href="#Git-基础" class="headerlink" title="Git 基础"></a>Git 基础</h2><h3 id="获取-Git-仓库"><a href="#获取-Git-仓库" class="headerlink" title="获取 Git 仓库"></a>获取 Git 仓库</h3><p>有两种方法：第一种是在现有项目或目录下导入所有文件到 Git 中；第二种是从一个服务器克隆一个现有的 Git 仓库。</p>
<h4 id="在现有目录中初始化仓库"><a href="#在现有目录中初始化仓库" class="headerlink" title="在现有目录中初始化仓库"></a>在现有目录中初始化仓库</h4><p>进入现有的项目目录，并输入：</p>
<pre><code>$ git init
</code></pre><p>该命令会创建一个名为 <code>.git</code> 的子目录。该命令仅仅是作了一个初始化的操作，项目里的文件还没有被跟踪。</p>
<p>如果是在一个已经存在文件的文件夹中初始化 Git 仓库来进行版本控制的话，可通过 <code>git add</code>命令来实现对指定文件的跟踪，然后执行<code>git commit</code>提交。例如：</p>
<pre><code>$ git add *.c
$ git add LICENSE
$ git commit -m &apos;initial project version&apos;
</code></pre><h4 id="克隆现有的仓库"><a href="#克隆现有的仓库" class="headerlink" title="克隆现有的仓库"></a>克隆现有的仓库</h4><p>可以使用<code>git clone</code>命令。克隆该 Git 仓库服务器上的几乎所有数据，而不是仅仅复制完成你的工作所需要的文件。默认配置下远程 Git 仓库的每一个文件的每一个版本都将被拉取下来。如果服务器的磁盘坏掉了，可以使用任何一个克隆下来的用户端来重建服务器上的仓库。</p>
<p>比如要克隆 Git 的可链接库 libgit2，可以用下面的命令：</p>
<pre><code>$ git clone https://github.com/libgit2/libgit2
</code></pre><p>如果想在克隆远程仓库的时候，自定义本地仓库的名字，可以使用如下命令：</p>
<pre><code>$ git clone https://github.com/libgit2/libgit2 mylibgit
</code></pre><p>这样，本地创建的仓库名字变为 <code>mylibgit</code>。</p>
<p>Git 支持多种数据传输协议。 上面的例子使用的是 <code>https://</code> 协议，不过你也可以使用 <code>git://</code> 协议或者使用 SSH 传输协议，比如 <code>user@server:path/to/repo.git</code> 。</p>
<h3 id="记录每次更新到仓库"><a href="#记录每次更新到仓库" class="headerlink" title="记录每次更新到仓库"></a>记录每次更新到仓库</h3><p>工作目录下的每个文件不外乎两种状态：已跟踪或未跟踪。<br>已跟踪：指那些被纳入版本控制的文件，在上一次快照中有它们的记录。<br>未跟踪：工作目录中除已跟踪文件以外的所有其它文件都属于未跟踪文件。它们既不存在于上次快照中，也没有放入暂存区。<br>初次克隆某个仓库的时候，工作目录的所有文件都属于已跟踪文件，并处于未修改状态。</p>
<p>编辑过某些文件后，Git 将它们标记为已修改文件。再将这些修改过的文件入入暂存区，然后提交所有暂存了的修改，如此反复。</p>
<img src="/2017/04/19/Git学习笔记/lifecycle.png" alt="文件状态变化周期" title="文件状态变化周期">
<h4 id="检查当前文件状态"><a href="#检查当前文件状态" class="headerlink" title="检查当前文件状态"></a>检查当前文件状态</h4><p>要查看哪些文件处于什么状态，可以用 <code>git status</code>命令。</p>
<p>如果在克隆仓库后立即使用此命令，会看到类似这样的输出：</p>
<pre><code>$ git status
On branch master
nothing to commit, working directory clean
</code></pre><p>说明现在的工作目录相当干净，所有已跟踪文件在上次提交后都未被更改过。</p>
<p>在项目下创建一个新的 README 文件，如果之前不存在这个文件，使用<code>git status</code>命令，你将看到一个新的未跟踪文件：</p>
<pre><code>$ echo &apos;My Project&apos; &gt; README
$ git status
On branch master
Untracked files:
  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)

    README

nothing added to commit but untracked files present (use &quot;git add&quot; to track)
</code></pre><p>在状态报告中可以看到新建的 README 文件出现在 <code>Untracked files</code>下面。未跟踪的文件意味着 Git 在之前的快照（提交）中没有这些该文，Git 不会自动将之纳入跟踪范围。除非你明明白白告诉它“我需要跟踪该文件”。</p>
<h4 id="跟踪新文件"><a href="#跟踪新文件" class="headerlink" title="跟踪新文件"></a>跟踪新文件</h4><p>使用命令 <code>git add</code>开始跟踪文件。要跟踪 README 文件，运行：</p>
<pre><code>$ git add README
</code></pre><p>再运行<code>git status</code>命令，会看到 README 文件已经被跟踪，并处于暂存状态：</p>
<pre><code>$ git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

    new file:   README
</code></pre><p>只要在<code>Changes to be committed</code>这行下面的，就说明是已暂存状态。<code>git add</code>命令使用文件或目录的路径作为参数，如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。</p>
<h4 id="暂存已修改文件"><a href="#暂存已修改文件" class="headerlink" title="暂存已修改文件"></a>暂存已修改文件</h4><p>如果你修改了一个名为 <code>CONTRIBUTING.md</code>的已被跟踪的文件，再运行<code>git status</code>命令，会看到下面内容：</p>
<pre><code>$ git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

    new file:   README

Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

    modified:   CONTRIBUTING.md
</code></pre><p>可以看到<code>CONTRIBUTING.md</code>文件已经被修改，且并未放到暂存区。要暂存这次更新，需要运行 <code>git add</code>命令。这是个多功能命令：可以用它开始跟踪新文件，或者把被修改的已跟踪文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。</p>
<p>将<code>git add</code>命令理解为“添加内容到下一次提交中”而不是“将一个文件添加到项目中”更加合适。</p>
<p>暂存<code>CONTRIBUTING.md</code>之后再看看<code>git status</code>的输出：</p>
<pre><code>$ git add CONTRIBUTING.md
$ git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

    new file:   README
    modified:   CONTRIBUTING.md、
</code></pre><p>如果你想再修改<code>CONTRIBUTING.md</code>文件，比如加一条注释，重新编辑存盘后，准备好提交。不过且慢，再运行<code>git status</code>看看：</p>
<pre><code>$ git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

    new file:   README
    modified:   CONTRIBUTING.md

Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

    modified:   CONTRIBUTING.md
</code></pre><p>可以看到<code>CONTRIBUTING.md</code>同时出现在暂存区和非暂存区。这是因为 Git 只不过暂存了你运行<code>git add</code>命令时的版本，如果你现在提交，<code>CONTRIBUTING.md</code>的版本是你最后一次运行<code>git add</code>命令时的那个版本，而不是你运行<code>git commit</code>时，在工作目录的当前版本。所以，运行了<code>git add</code>之后又作为修订的文件，需要重新运行<code>git add</code>把最新版本重新暂存起来：</p>
<pre><code>$ git add CONTRIBUTING.md
$ git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

    new file:   README
    modified:   CONTRIBUTING.md
</code></pre><h4 id="状态简览"><a href="#状态简览" class="headerlink" title="状态简览"></a>状态简览</h4><p><code>git status</code>命令输出十分详细，可以使用 <code>git status -s</code>，你将得到一种更为紧凑的格式输出：</p>
<pre><code>$ git status -s
 M README
MM Rakefile
A  lib/git.rb
M  lib/simplegit.rb
?? LICENSE.txt
</code></pre><p>新添加的末跟踪文件前面有<code>??</code>标记，新添加到暂存区中的文件前面有<code>A</code>标记，修改过的文件前面有<code>M</code>标记。<code>M</code>有两个可以出现的位置，出现在右边的<code>M</code>表示该文件被修改了但是还没放入区，出现在靠左边的<code>M</code>表示该文件被修改了并放入了暂存区。<code>Rakefile</code> 前面有两个位置都出现了<code>M</code>，表示该文件修改了提交暂存区后又再次被修改。</p>
<h4 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h4><p>一些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件，无需纳入 Git 的管理，也不希望它们总出现在末跟踪文件列表。可以创建一个名为<code>.gitignore</code>的文件，列出要忽略的文件模式，例如：</p>
<pre><code>$ cat .gitignore
*.[oa]
*~
</code></pre><p>表示告诉 Git 忽略所有以 <code>.o</code> 或 <code>.a</code>结尾的文件，以用以波浪符(~)结尾的文件。</p>
<p>文件<code>.gitignore</code>的格式规范如下：</p>
<ul>
<li>所有空行或者以<code>#</code>开头的行都会被 Git 忽略。</li>
<li>可以使用标准的 glob 模式匹配。</li>
<li>匹配模式可以以（<code>/</code>）开头防止递归。</li>
<li>匹配模式可以以（<code>/</code>）结尾指定目录。</li>
<li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（<code>!</code>）取反。</li>
</ul>
<p>所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。 星号（<code>*</code>）匹配零个或多个任意字符；<code>[abc]</code> 匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；问号（<code>?</code>）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 <code>[0-9]</code> 表示匹配所有 0 到 9 的数字）。 使用两个星号（<code>*</code>） 表示匹配任意中间目录，比如<code>a/**/z</code> 可以匹配 a/z, a/b/z 或 <code>a/b/c/z</code>等。</p>
<h4 id="查看已暂存和未暂存的修改"><a href="#查看已暂存和未暂存的修改" class="headerlink" title="查看已暂存和未暂存的修改"></a>查看已暂存和未暂存的修改</h4><p>使用<code>git diff</code>命令，将通过文件补丁的格式显示具体哪些行发生了改变。</p>
<p>要查看尚未暂存的文件更新了哪些部分，不加参数直接输入<code>git diff</code>：</p>
<pre><code>$ git diff
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -65,7 +65,8 @@ branch directly, things can get messy.
 Please include a nice description of your changes when you submit your PR;
 if we have to read the whole diff to figure out why you&apos;re contributing
 in the first place, you&apos;re less likely to get feedback and have your change
-merged in.
+merged in. Also, split your changes into comprehensive chunks if your patch is
+longer than a dozen lines.

 If you are starting to work on a particular area, feel free to submit a PR
 that highlights your work in progress (and note in the PR title that it&apos;s
</code></pre><p>此命令比较的是工作目录中当前文件和暂存区快照之间的差异，也就是修改之后不穿堂风有暂存起来的变化内容。</p>
<p>要查看已暂存的将要添加到下次提交里的内容，可以用<code>git diff --cached</code>或<code>git diff --staged</code>命令。</p>
<pre><code>$ git diff --cached
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -65,7 +65,8 @@ branch directly, things can get messy.
 Please include a nice description of your changes when you submit your PR;
 if we have to read the whole diff to figure out why you&apos;re contributing
 in the first place, you&apos;re less likely to get feedback and have your change
-merged in.
+merged in. Also, split your changes into comprehensive chunks if your patch is
+longer than a dozen lines.

 If you are starting to work on a particular area, feel free to submit a PR
 that highlights your work in progress (and note in the PR title that it&apos;s
</code></pre><h4 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h4><p>在提交更新之前，请务必先用<code>git status</code>看下，是不是所有新建或修改过的文件都已经暂存起来了，然后再运行提交命令<code>git commit</code>：</p>
<pre><code>$ git commit
</code></pre><p>这种方式会启动文本编辑器以便输入本次提交的说明 。默认的提交消息包含最后一次运行<code>git status</code>的输出，放在注释行里，另外开头还有一空行，供你输入提交说明。如果想要更详细的对修改了哪些内容的提示，可以用<code>-v</code>选项，这会将你所做的改变的diff输出放到编辑器中。退出编辑器时，Git 会丢掉注释行，用你输入提交附带信息生成一次提交。</p>
<p>可以在<code>git commit</code>命令后添加<code>-m</code>选项，将提交信息与命令放在同一行，如下所示：</p>
<pre><code>$ git commit -m &quot;Story 182: Fix benchmarks for speed&quot;
[master 463dc4f] Story 182: Fix benchmarks for speed
 2 files changed, 2 insertions(+)
 create mode 100644 README
</code></pre><p>提交结果会告诉你，当前是哪个分支提交的，本次提交的完整SHA-1校验和是什么，以及在本次提交中有多少文件修订过，多少行添加和删改过。</p>
<p>每次提交都是对项目作一次快照，以后可以回到这个状态，或者进行比较。</p>
<h4 id="跳过使用暂存区域"><a href="#跳过使用暂存区域" class="headerlink" title="跳过使用暂存区域"></a>跳过使用暂存区域</h4><p>Git 提供了一个跳过使用暂存区域的方式，只要在提交的时候，给<code>git commit</code>加上<code>-a</code>选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过<code>git add</code>步骤。</p>
<h4 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h4><p>要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除。可以用<code>git rm</code>命令完成些项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在末跟踪文件清单中了。</p>
<p>如果只是简单地从工作目录中手工删除文件，运行<code>git status</code>时就会在未暂存清单看到：</p>
<pre><code>$ rm PROJECTS.md
$ git status
On branch master
Your branch is up-to-date with &apos;origin/master&apos;.
Changes not staged for commit:
  (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

        deleted:    PROJECTS.md

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
</code></pre><p>然后再运行<code>git rm</code>记录此次移除文件的操作：</p>
<pre><code>$ git rm PROJECTS.md
rm &apos;PROJECTS.md&apos;
$ git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

    deleted:    PROJECTS.md
</code></pre><p>下一次提交时，该文件就不再纳入版本管理了。</p>
<p>如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项<code>-f</code>。这是一种安全特性，用于防止误删还没有添加到快照的数据，这样的数据不能被 Git 恢复。</p>
<p>另外一种情况是，我们想把文件从 Git 仓库中删除（变即从暂存区域移除），但仍然希望保留在当前工作目录中。换句话说，你想让文件保留在磁盘，但是并不想让 Git 继续跟踪。为达到这一目的，使用<code>--cached</code>选项。例如：</p>
<pre><code>$ git rm --cached README
</code></pre><p><code>git rm</code>命令后面可以列出文件或者目录的名字，也可以使用<code>glob</code>模式，比方说：</p>
<pre><code>$ git rm log/\*.log
</code></pre><p>注意到星号<code>*</code>之前的反斜杠<code>\</code>，因为 Git 有它自己的文件模式扩展匹配方式，所以我们不用 shell 来帮忙展开。此命令删除<code>log/</code>目录下扩展名为<code>.log</code>的所有文件。</p>
<h4 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h4><p>Git 并不显式跟踪文件移动操作。如果在 Git 中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。</p>
<p>要在 Git 中对文件改名，可以这么做：</p>
<pre><code>$ git mv file_from file_to
</code></pre><p>查看状态信息，也是明白无误地看到关于重命名操作的说明：</p>
<pre><code>$ git mv README.md README
$ git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

    renamed:    README.md -&gt; README
</code></pre><p>其实，运行<code>git mv</code>就相当于运行了下面三条命令：</p>
<pre><code>$ mv README.md README
$ git rm README.md
$ git add README
</code></pre><p>如此分开操作，Git 也会意识到这是一次改名，所以不管何种方式结果都一样。两者唯一的区别是，<code>mv</code>是一条命令，而另一种方式需要三条命令，直接用<code>git mv</code>轻便得多。</p>
<h3 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h3><p>要回顾提交历史，可以使用<code>git log</code>命令，默认不用任何参数的话，类似以下输出：</p>
<pre><code>$ git log
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Mon Mar 17 21:52:11 2008 -0700

    changed the version number

commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Sat Mar 15 16:40:33 2008 -0700

    removed unnecessary test

commit a11bef06a3f659402fe7563abf99ad00de2209e6
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Sat Mar 15 10:31:28 2008 -0700

    first commit
</code></pre><p><code>git log</code>会按提交时间列出所有的更新，最近的更新排在最上面，并列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明。</p>
<h4 id="显示每交提交内容差异"><a href="#显示每交提交内容差异" class="headerlink" title="显示每交提交内容差异"></a>显示每交提交内容差异</h4><p>一个常用的选项是<code>-p</code>，用来显示每次提交的内容差异。你也可以加上<code>-2</code>来仅显示最近两次提交：</p>
<pre><code>$ git log -p -2
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Mon Mar 17 21:52:11 2008 -0700

    changed the version number

diff --git a/Rakefile b/Rakefile
index a874b73..8f94139 100644
--- a/Rakefile
+++ b/Rakefile
@@ -5,7 +5,7 @@ require &apos;rake/gempackagetask&apos;
 spec = Gem::Specification.new do |s|
     s.platform  =   Gem::Platform::RUBY
     s.name      =   &quot;simplegit&quot;
-    s.version   =   &quot;0.1.0&quot;
+    s.version   =   &quot;0.1.1&quot;
     s.author    =   &quot;Scott Chacon&quot;
     s.email     =   &quot;schacon@gee-mail.com&quot;
     s.summary   =   &quot;A simple gem for using Git in Ruby code.&quot;

commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Sat Mar 15 16:40:33 2008 -0700

    removed unnecessary test

diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index a0a60ae..47c6340 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -18,8 +18,3 @@ class SimpleGit
     end

 end
-
-if $0 == __FILE__
-  git = SimpleGit.new
-  puts git.show
-end
\ No newline at end of file
</code></pre><p>当进行代码审查，或者快速浏览某个搭档提交的 commit 所带来的变化的时候，这个参数就非常有用了。</p>
<h4 id="查看提交统计信息"><a href="#查看提交统计信息" class="headerlink" title="查看提交统计信息"></a>查看提交统计信息</h4><p>可以使用<code>--stat</code>选项查看每次提交的简略的统计信息：</p>
<pre><code>$ git log --stat
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Mon Mar 17 21:52:11 2008 -0700

    changed the version number

 Rakefile | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Sat Mar 15 16:40:33 2008 -0700

    removed unnecessary test

 lib/simplegit.rb | 5 -----
 1 file changed, 5 deletions(-)

commit a11bef06a3f659402fe7563abf99ad00de2209e6
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Sat Mar 15 10:31:28 2008 -0700

    first commit

 README           |  6 ++++++
 Rakefile         | 23 +++++++++++++++++++++++
 lib/simplegit.rb | 25 +++++++++++++++++++++++++
 3 files changed, 54 insertions(+)
</code></pre><p><code>--stat</code>选项在每次提交的下面列出所有被修改过的文件、有多少文件被修改了以及被修改过的文件的哪些行被移除或是添加了。在每次提交的最后还有一个总结。</p>
<h4 id="定制输出格式和内容"><a href="#定制输出格式和内容" class="headerlink" title="定制输出格式和内容"></a>定制输出格式和内容</h4><p>另外一个常用的选项是<code>--pretty</code>。这个选项可以指定使用不同于默认格式的方式展示提交历史。这个选项有一些内建的子选项供你使用。比如用<code>oneline</code>将每个提交放在一行显示，查看的提交数很大时非常有用。另外还有<code>short</code>，<code>full</code>和<code>fuller</code>可以用，展示的信息或多或少有些不同。</p>
<pre><code>$ git log --pretty=oneline
ca82a6dff817ec66f44342007202690a93763949 changed the version number
085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 removed unnecessary test
a11bef06a3f659402fe7563abf99ad00de2209e6 first commit
</code></pre><p><code>format</code>可以定制要显示的记录格式。这样的输出对后期提取分析格外有用，因为你知道输出的格式不会随着 Git 的更新而发生改变：</p>
<pre><code>$ git log --pretty=format:&quot;%h - %an, %ar : %s&quot;
ca82a6d - Scott Chacon, 6 years ago : changed the version number
085bb3b - Scott Chacon, 6 years ago : removed unnecessary test
a11bef0 - Scott Chacon, 6 years ago : first commit
</code></pre><p>下面的表格列出了<code>git log --pretty=format</code>常用的格式点位符写法及其代表的意义。</p>
<table>
<thead>
<tr>
<th style="text-align:left">选项</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>%H</code></td>
<td style="text-align:left">提交对象（commit）的完整哈希字串</td>
</tr>
<tr>
<td style="text-align:left"><code>%h</code></td>
<td style="text-align:left">提交对象的简短哈希字串</td>
</tr>
<tr>
<td style="text-align:left"><code>%T</code></td>
<td style="text-align:left">树对象（tree）的完整哈希字串</td>
</tr>
<tr>
<td style="text-align:left"><code>%t</code></td>
<td style="text-align:left">树对象的简短哈希字串</td>
</tr>
<tr>
<td style="text-align:left"><code>%P</code></td>
<td style="text-align:left">父对象（parent）的完整哈希字串</td>
</tr>
<tr>
<td style="text-align:left"><code>%p</code></td>
<td style="text-align:left">父对象的简短哈希字串</td>
</tr>
<tr>
<td style="text-align:left"><code>%an</code></td>
<td style="text-align:left">作者（author）的名字</td>
</tr>
<tr>
<td style="text-align:left"><code>%ae</code></td>
<td style="text-align:left">作者的电子邮件地址</td>
</tr>
<tr>
<td style="text-align:left"><code>%ad</code></td>
<td style="text-align:left">作者修订日期（可以用 –date= 选项定制格式）</td>
</tr>
<tr>
<td style="text-align:left"><code>%ar</code></td>
<td style="text-align:left">作者修订日期，按多久以前的方式显示</td>
</tr>
<tr>
<td style="text-align:left"><code>%cn</code></td>
<td style="text-align:left">提交者（committer）的名字</td>
</tr>
<tr>
<td style="text-align:left"><code>%ce</code></td>
<td style="text-align:left">提交者的电子邮件地址</td>
</tr>
<tr>
<td style="text-align:left"><code>%cd</code></td>
<td style="text-align:left">提交日期</td>
</tr>
<tr>
<td style="text-align:left"><code>%cr</code></td>
<td style="text-align:left">提交日期，按多久以前的方式显示</td>
</tr>
<tr>
<td style="text-align:left"><code>%s</code></td>
<td style="text-align:left">提交说明</td>
</tr>
</tbody>
</table>
<p>以下是<code>git log</code>的常用选项。</p>
<table>
<thead>
<tr>
<th style="text-align:left">选项</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-p</td>
<td style="text-align:left">按补丁格式显示每个更新之间的差异。</td>
</tr>
<tr>
<td style="text-align:left">–stat</td>
<td style="text-align:left">显示每次更新的文件修改统计信息。</td>
</tr>
<tr>
<td style="text-align:left">–shortstat</td>
<td style="text-align:left">只显示 –stat 中最后的行数修改添加移除统计。</td>
</tr>
<tr>
<td style="text-align:left">–name-only</td>
<td style="text-align:left">仅在提交信息后显示已修改的文件清单。</td>
</tr>
<tr>
<td style="text-align:left">–name-status</td>
<td style="text-align:left">显示新增、修改、删除的文件清单。</td>
</tr>
<tr>
<td style="text-align:left">–abbrev-commit</td>
<td style="text-align:left">仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。</td>
</tr>
<tr>
<td style="text-align:left">–relative-date</td>
<td style="text-align:left">使用较短的相对时间显示（比如，“2 weeks ago”）。</td>
</tr>
<tr>
<td style="text-align:left">–graph</td>
<td style="text-align:left">显示 ASCII 图形表示的分支合并历史。</td>
</tr>
<tr>
<td style="text-align:left">–pretty</td>
<td style="text-align:left">使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。</td>
</tr>
</tbody>
</table>
<h4 id="限制输出长度"><a href="#限制输出长度" class="headerlink" title="限制输出长度"></a>限制输出长度</h4><p><code>git log</code>有许多非常实用的限制输出长度的选项。<code>-&lt;n&gt;</code>表示仅显示最近的 n 条提交，n 可以是任何整数。实践中不太用这个选项，Git 在输出所有提交时会自动调用分页程序，所以你一次只会看到一页的内容。</p>
<p>另外还有按照时间作限制的选项，比如<code>--since</code>和<code>--until</code>。下面的命令列出所有最近两周内的提交</p>
<pre><code>$ git log --since=2.weeks
</code></pre><p>这个命令可以在多种格式下工作，比如说具体的某一天<code>2008-01-15</code>，或者是相对地多久以前“2 years 1 day 3 minutes ago”。</p>
<p>还可以给出若干搜索条件，列出符合的提交。用<code>--author</code>选项显示指定作者的提交，用<code>--grep</code>选项搜索提交说明中的关键字。（如果要得到同时满足这两个选项搜索条件的提交，就必须用 <code>--all-match</code>选项。否则，满足任意一个条件的提交都会被匹配出来）</p>
<p>另一个非常有用的筛选选项是<code>-S</code>，可以列出那些添加或移除了某些字符串的提交。比如说，你想找出添加或移除了某一个特定函数的引用的提交，你可以这样使用：</p>
<pre><code>$ git log -Sfunction_name
</code></pre><p>最后一个很实用的<code>git log</code>选项是路径（path），如果只关心某些文件或者目录的历史提交，可以在<code>git log</code>选项的最后指定它们的路径。因为是放在最后位置上的选项，所以用两个短划线（–）隔开之前的选项和后面限定的路径名。</p>
<p>以下表格是限制<code>git log</code>输出的选项。</p>
<table>
<thead>
<tr>
<th style="text-align:left">选项</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>-(n)</code></td>
<td style="text-align:left">仅显示最近的 n 条提交</td>
</tr>
<tr>
<td style="text-align:left"><code>--since</code>, <code>--after</code></td>
<td style="text-align:left">仅显示指定时间之后的提交。</td>
</tr>
<tr>
<td style="text-align:left"><code>--until</code>, <code>--before</code></td>
<td style="text-align:left">仅显示指定时间之前的提交。</td>
</tr>
<tr>
<td style="text-align:left"><code>--author</code></td>
<td style="text-align:left">仅显示指定作者相关的提交。</td>
</tr>
<tr>
<td style="text-align:left"><code>--committer</code></td>
<td style="text-align:left">仅显示指定提交者相关的提交。</td>
</tr>
<tr>
<td style="text-align:left"><code>--grep</code></td>
<td style="text-align:left">仅显示含指定关键字的提交</td>
</tr>
<tr>
<td style="text-align:left"><code>-S</code></td>
<td style="text-align:left">仅显示添加或移除了某个关键字的提交</td>
</tr>
</tbody>
</table>
<p>来看一个实际的例子，如果要查看 Git 仓库中，2008 年 10 月期间，Junio Hamano 提交的但未合并的测试文件，可以用下面的查询命令：</p>
<pre><code>$ git log --pretty=&quot;%h - %s&quot; --author=gitster --since=&quot;2008-10-01&quot; \
   --before=&quot;2008-11-01&quot; --no-merges -- t/
5610e3b - Fix testcase failure when extended attributes are in use
acd3b9e - Enhance hold_lock_file_for_{update,append}() API
f563754 - demonstrate breakage of detached checkout with symbolic link HEAD
d1a43f2 - reset --hard/read-tree --reset -u: remove unmerged new paths
51a94af - Fix &quot;checkout --track -b newbranch&quot; on detached HEAD
b0ad11e - pull: allow &quot;git pull origin $something:$current_branch&quot; into an unborn branch
</code></pre><p>在近 40000 条提交中，上面的输出仅列出了符合条件的 6 条记录。</p>
<h3 id="撤消操作"><a href="#撤消操作" class="headerlink" title="撤消操作"></a>撤消操作</h3><h4 id="覆盖上一次提交"><a href="#覆盖上一次提交" class="headerlink" title="覆盖上一次提交"></a>覆盖上一次提交</h4><p>有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。此时，可以运行带有<code>--amend</code>选项的提交命令尝试重新提交：</p>
<pre><code>$ git commit --amend
</code></pre><p>这个命令会将暂存区的文件提交。如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行些命令），那么快照会保持不变，而你所修改的只是提交信息。新的提交信息会覆盖旧的提交信息。</p>
<p>例如，提交后发现忘记了暂存某些需要的修改，可以像下面这样操作：</p>
<pre><code>$ git commit -m &apos;initial commit&apos;
$ git add forgotten_file
$ git commit --amend
</code></pre><p>最终你只会有一个提交，第二次提交将代替第一次提交的结果。</p>
<h4 id="取消暂存的文件"><a href="#取消暂存的文件" class="headerlink" title="取消暂存的文件"></a>取消暂存的文件</h4><p>使用<code>git reset HEAD &lt;file&gt;...</code>可以取消暂存指定的文件。</p>
<h4 id="撤消对文件的修改"><a href="#撤消对文件的修改" class="headerlink" title="撤消对文件的修改"></a>撤消对文件的修改</h4><p>如果想将已经被修改的文件恢复到上次提交成功的状态，可以使用<code>git checkout -- &lt;file&gt;...</code>命令撤消之前所做的修改。</p>
<p>记住，在 Git 中任何已提交的东西几乎总是可以恢复的。甚至那些被删除的分支中的提交或使用<code>--amend</code>选项覆盖的提交也可以恢复。然而，任何你未提交的东西丢失后很可能再也找不到了。</p>
<h3 id="远程仓库的使用"><a href="#远程仓库的使用" class="headerlink" title="远程仓库的使用"></a>远程仓库的使用</h3><h4 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h4><p>如果想查看已经配置的远程仓库服务器，可以运行<code>git remote</code>命令，它会列出你指定的每一个远程服务器的简写。如果你已经克隆了自己的仓库，那么至少可以看到 origin –这是Git 给你克隆的仓库服务器的默认名字。</p>
<p>也可以指定选项<code>-v</code>，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。</p>
]]></content>
      
        <categories>
            
            <category> Git </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Git </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo简易使用手册]]></title>
      <url>http://blog.zhiyuanep.net/2017/04/17/Hexo%E7%AE%80%E6%98%93%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
      <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>这篇文章只摘取了自己认为重要的信息，方便日后查找。具体请参考 <a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="external">Hexo 官方文档</a>。</p>
<h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h4><p>在安装 Hexo 之前，请确保系统已经安装了以下软件：</p>
<ul>
<li><a href="http://nodejs.org/" target="_blank" rel="external">Node.js</a></li>
<li><a href="http://git-scm.com/" target="_blank" rel="external">Git</a></li>
</ul>
<h4 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h4><pre><code>$ npm install -g hexo-cli
</code></pre><hr>
<h3 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h3><p>执行以下命令初始化博客项目，其中 <code>&lt;folder&gt;</code> 为博客目录名称。</p>
<pre><code>$ hexo init &lt;folder&gt;
$ cd &lt;folder&gt;
</code></pre><h3 id="文件说明"><a href="#文件说明" class="headerlink" title="文件说明"></a>文件说明</h3><p>新建完成后，生成的文件目录如下：</p>
<pre><code>├── _config.yml
├── package.json
├── scaffolds
├── source
|   ├── _drafts
|   └── _posts
└── themes
</code></pre><h4 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h4><p>博客的配置文件，可以配置生成器、插件、站点信息等大部分参数。</p>
<h4 id="scaffolds"><a href="#scaffolds" class="headerlink" title="scaffolds"></a>scaffolds</h4><p>模板文件夹。新建文章时，Hexo 会根据 scaffolds 来填充新建的 markdown 文件的内容。</p>
<h4 id="source"><a href="#source" class="headerlink" title="source"></a>source</h4><p>存放用户资源的地方。除了 <code>_posts</code> 文件夹之外，开头命名为 <code>_</code> 的文件/文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 <code>public</code> 文件夹，而其它文件会被挎贝过去。</p>
<h4 id="themes"><a href="#themes" class="headerlink" title="themes"></a>themes</h4><p>主题文件夹。Hexo 会根据主题来生成静态页面。</p>
<hr>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>可以在 <code>_config.yml</code> 修改大部分配置。</p>
<h4 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h4><table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>title</code></td>
<td style="text-align:left">网站标题</td>
</tr>
<tr>
<td style="text-align:left"><code>subtitle</code></td>
<td style="text-align:left">网站副标题</td>
</tr>
<tr>
<td style="text-align:left"><code>description</code></td>
<td style="text-align:left">网站描述</td>
</tr>
<tr>
<td style="text-align:left"><code>author</code></td>
<td style="text-align:left">您的名字</td>
</tr>
<tr>
<td style="text-align:left"><code>language</code></td>
<td style="text-align:left">网站使用的语言</td>
</tr>
<tr>
<td style="text-align:left"><code>timezone</code></td>
<td style="text-align:left">网站时区，Hexo 默认使用您电脑的时区。<a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones" target="_blank" rel="external">时区列表</a>。比如说：<code>America/New_York</code>，<code>Asia/Shanghai</code></td>
</tr>
</tbody>
</table>
<p>其中，<code>description</code> 主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。<code>author</code> 参数用于主题显示文章的作者。</p>
<h4 id="网址"><a href="#网址" class="headerlink" title="网址"></a>网址</h4><table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>url</code></td>
<td style="text-align:left">网址</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>root</code></td>
<td style="text-align:left">网站根目录</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>permalink</code></td>
<td style="text-align:left">文章的永久链接格式</td>
<td style="text-align:left"><code>:year/:month:/day/:title/</code></td>
</tr>
<tr>
<td style="text-align:left"><code>permalink_defaults</code></td>
<td style="text-align:left">永久链接中各部分的默认值</td>
</tr>
</tbody>
</table>
<p>如果您的网站存在于子目录中，例如 <code>http://yoursite.com/blog</code>，则请将 <code>url</code> 设为 <code>http://yoursite.com/blog</code> 并把 <code>root</code> 设为 <code>/blog/</code>。</p>
<h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>source_dir</code></td>
<td style="text-align:left">资源文件夹，这个文件夹来存放内容。</td>
<td style="text-align:left">source</td>
</tr>
<tr>
<td style="text-align:left"><code>public_dir</code></td>
<td style="text-align:left">公共文件夹，这个文件夹用于存放生成的站点文件。</td>
<td style="text-align:left">public</td>
</tr>
<tr>
<td style="text-align:left"><code>tag_dir</code></td>
<td style="text-align:left">标签文件夹</td>
<td style="text-align:left">tags</td>
</tr>
<tr>
<td style="text-align:left"><code>archive_dir</code></td>
<td style="text-align:left">归档文件夹</td>
<td style="text-align:left">archives</td>
</tr>
<tr>
<td style="text-align:left"><code>category_dir</code></td>
<td style="text-align:left">分类文件夹</td>
<td style="text-align:left">categories</td>
</tr>
<tr>
<td style="text-align:left"><code>code_dir</code></td>
<td style="text-align:left">include code 文件夹</td>
<td style="text-align:left">downloads/code</td>
</tr>
<tr>
<td style="text-align:left"><code>i18n_dir</code></td>
<td style="text-align:left">国际化（i18n）文件夹</td>
<td style="text-align:left">:lang</td>
</tr>
<tr>
<td style="text-align:left"><code>skip_render</code></td>
<td style="text-align:left">路过指定文件的渲染，您可使用 glob 表达式来匹配路径。</td>
</tr>
</tbody>
</table>
<h4 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h4><table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>new_post_name</code></td>
<td style="text-align:left">新文章的文件名称</td>
<td style="text-align:left">:title.md</td>
</tr>
<tr>
<td style="text-align:left"><code>default_layout</code></td>
<td style="text-align:left">预设布局</td>
<td style="text-align:left">post</td>
</tr>
<tr>
<td style="text-align:left"><code>auto_spacing</code></td>
<td style="text-align:left">在中文和英文之间加入空格</td>
<td style="text-align:left">false</td>
</tr>
<tr>
<td style="text-align:left"><code>titlecase</code></td>
<td style="text-align:left">把标题转换为 title case</td>
<td style="text-align:left">false</td>
</tr>
<tr>
<td style="text-align:left"><code>external_link</code></td>
<td style="text-align:left">在新标签中打开链接</td>
<td style="text-align:left">true</td>
</tr>
<tr>
<td style="text-align:left"><code>filename_case</code></td>
<td style="text-align:left">把文件名称转换为(1)小写或(2)大写</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left"><code>render_drafts</code></td>
<td style="text-align:left">显示草稿</td>
<td style="text-align:left">false</td>
</tr>
<tr>
<td style="text-align:left"><code>post_asset_folder</code></td>
<td style="text-align:left">启动 Asset 文件夹</td>
<td style="text-align:left">false</td>
</tr>
<tr>
<td style="text-align:left"><code>relative_link</code></td>
<td style="text-align:left">把链接改为与根目录的相对位址</td>
<td style="text-align:left">false</td>
</tr>
<tr>
<td style="text-align:left"><code>future</code></td>
<td style="text-align:left">显示未来的文章</td>
<td style="text-align:left">true</td>
</tr>
<tr>
<td style="text-align:left"><code>highlight</code></td>
<td style="text-align:left">代码块的设置</td>
</tr>
</tbody>
</table>
<p>默认情况下，Hexo 生成的超链接都是绝对地址。而相对链接无论用什么域名访问该站点都没有关系，这在进行反向代理时可能用到。通常情况下，建议使用绝对地址。</p>
<h4 id="分类-amp-标签"><a href="#分类-amp-标签" class="headerlink" title="分类&amp;标签"></a>分类&amp;标签</h4><table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>default_category</code></td>
<td style="text-align:left">默认分类</td>
<td style="text-align:left">uncategorized</td>
</tr>
<tr>
<td style="text-align:left"><code>category_map</code></td>
<td style="text-align:left">分类别名</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>tag_map</code></td>
<td style="text-align:left">标签别名</td>
</tr>
</tbody>
</table>
<h4 id="日期-时间"><a href="#日期-时间" class="headerlink" title="日期/时间"></a>日期/时间</h4><p>Hexo 使用 <a href="http://momentjs.com/" target="_blank" rel="external">Moment.js</a>来解析和显示时间。</p>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>date_format</code></td>
<td style="text-align:left">日期格式</td>
<td style="text-align:left">YYYY-MM-DD</td>
</tr>
<tr>
<td style="text-align:left"><code>time_format</code></td>
<td style="text-align:left">时间格式</td>
<td style="text-align:left">H:mm:ss</td>
</tr>
</tbody>
</table>
<h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>per_page</code></td>
<td style="text-align:left">每页显示的文章量（0=关闭分页功能）</td>
<td style="text-align:left">10</td>
</tr>
<tr>
<td style="text-align:left"><code>pagination_dir</code></td>
<td style="text-align:left">分页目录</td>
<td style="text-align:left">page</td>
</tr>
</tbody>
</table>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>theme</code></td>
<td style="text-align:left">当前主题名称。值为 <code>false</code> 时禁用主题</td>
</tr>
<tr>
<td style="text-align:left"><code>deploy</code></td>
<td style="text-align:left">部署部分的设置</td>
</tr>
</tbody>
</table>
<p>关于 <code>deploy</code> 的详细设置请参考<a href="#部署">此处</a>。</p>
<hr>
<h3 id="Hexo-指令"><a href="#Hexo-指令" class="headerlink" title="Hexo 指令"></a>Hexo 指令</h3><h4 id="init"><a href="#init" class="headerlink" title="init"></a>init</h4><pre><code>$ hexo new [folder]
</code></pre><p>新建一个网站。如果 <code>folder</code> 为空，则默认在当前目录建立网站。</p>
<h4 id="new"><a href="#new" class="headerlink" title="new"></a>new</h4><pre><code>$ hexo new [layout] &lt;title&gt;
</code></pre><p>新建一篇文章。如果没有指定 <code>layout</code>，默认使用 <a href="#文章">_config.yml</a>中的 <code>default_layout</code> 参数代替。如果标题包含空格的话，请使用引号括起来。</p>
<h4 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h4><pre><code>$ hexo generate
</code></pre><p>或：</p>
<pre><code>$ hexo g
</code></pre><p>生成静态文件。</p>
<table>
<thead>
<tr>
<th style="text-align:left">选项</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>-d</code>, <code>--deploy</code></td>
<td style="text-align:left">文件生成后立即部署网站</td>
</tr>
<tr>
<td style="text-align:left"><code>-w</code>, <code>--watch</code></td>
<td style="text-align:left">监视文件变动</td>
</tr>
</tbody>
</table>
<h4 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h4><pre><code>$ hexo publish [layout] &lt;filename&gt;
</code></pre><p>发表草稿。</p>
<h4 id="server"><a href="#server" class="headerlink" title="server"></a>server</h4><pre><code>$ hexo server
</code></pre><p>或：</p>
<pre><code>$ hexo s
</code></pre><p>启动服务器。默认情况下，访问网址为：<code>http://localhost:4000/</code>。</p>
<p>Hexo 3.0 把服务器独立成了个别模块，您必须先安装 hexo-server 才能使用。</p>
<pre><code>$ npm install hexo-server --save
</code></pre><table>
<thead>
<tr>
<th style="text-align:left">选项</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>-p</code>, <code>--port</code></td>
<td style="text-align:left">重设端口</td>
</tr>
<tr>
<td style="text-align:left"><code>-s</code>, <code>--static</code></td>
<td style="text-align:left">只使用静态文件</td>
</tr>
<tr>
<td style="text-align:left"><code>-l</code>, <code>--log</code></td>
<td style="text-align:left">启动日记记录，使用覆盖记录格式</td>
</tr>
</tbody>
</table>
<h4 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h4><pre><code>$ hexo deploy
</code></pre><p>或：</p>
<pre><code>$ hexo d
</code></pre><p>部署网站。</p>
<table>
<thead>
<tr>
<th style="text-align:left">选项</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>-g</code>, <code>--generate</code></td>
<td style="text-align:left">部署之前预先生成静态文件</td>
</tr>
</tbody>
</table>
<h4 id="rendder"><a href="#rendder" class="headerlink" title="rendder"></a>rendder</h4><pre><code>$ hexo render &lt;file1&gt; [file2] ...
</code></pre><p>渲染文件。</p>
<table>
<thead>
<tr>
<th style="text-align:left">选项</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>-o</code>, <code>--output</code></td>
<td style="text-align:left">设置输出路径</td>
</tr>
</tbody>
</table>
<h4 id="migrate"><a href="#migrate" class="headerlink" title="migrate"></a>migrate</h4><pre><code>$ hexo migrate &lt;type&gt;
</code></pre><p>从其它博客系统迁移内容，具体参考<a href="https://hexo.io/zh-cn/docs/migration.html" target="_blank" rel="external">此处</a>。</p>
<h4 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h4><pre><code>$ hexo clean
</code></pre><p>清除缓存文件（<code>db.json</code>）和已生成的静态文件（<code>public</code>）。</p>
<h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><pre><code>$ hexo list
</code></pre><p>列出网站资料。</p>
<h4 id="version"><a href="#version" class="headerlink" title="version"></a>version</h4><pre><code>$ hexo version
</code></pre><p>显示 Hexo 版本。</p>
<h4 id="全局选项"><a href="#全局选项" class="headerlink" title="全局选项"></a>全局选项</h4><h5 id="安全模式"><a href="#安全模式" class="headerlink" title="安全模式"></a>安全模式</h5><pre><code>$ hexo --safe
</code></pre><p>安全模式下，不会载入插件和脚本。如果在安装新插件时遭遇问题，可以尝试以安全模式重新执行。</p>
<h5 id="调试模式"><a href="#调试模式" class="headerlink" title="调试模式"></a>调试模式</h5><pre><code>$ hexo --debug
</code></pre><p>在终端中显示调试信息并记录到 <code>debug.log</code>。</p>
<h5 id="简洁模式"><a href="#简洁模式" class="headerlink" title="简洁模式"></a>简洁模式</h5><pre><code>$ hexo --slient
</code></pre><p>隐藏终端信息。</p>
<h5 id="自定义配置文件的路径"><a href="#自定义配置文件的路径" class="headerlink" title="自定义配置文件的路径"></a>自定义配置文件的路径</h5><pre><code>$ hexo --config custom.yml
</code></pre><p>自定义配置文件路径，执行后将不再使用 <code>_config.yml</code>。</p>
<h5 id="显示草稿"><a href="#显示草稿" class="headerlink" title="显示草稿"></a>显示草稿</h5><pre><code>$ hexo --draft
</code></pre><p>显示 <code>source/_drafts</code> 文件夹中的草稿文章。</p>
<h5 id="自定义CWD"><a href="#自定义CWD" class="headerlink" title="自定义CWD"></a>自定义CWD</h5><pre><code>$ hexo --cwd /path/to/cwd
</code></pre><p>自定义当前工作目录 (current working directory) 的路径。</p>
<hr>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h3><p>通过以下命令创建一篇文章。</p>
<pre><code>$ hexo new [layout] &lt;title&gt;
</code></pre><p>默认布局为 <code>post</code>。</p>
<h4 id="布局（Layout）"><a href="#布局（Layout）" class="headerlink" title="布局（Layout）"></a>布局（Layout）</h4><p>Hexo 有三种默认布局：<code>post</code>、<code>page</code> 和 <code>draft</code>，它们分别对应不同的路径，而您自定义的其它布局和 <code>post</code> 相同，都将会储存到 <code>source/_posts</code> 文件夹。</p>
<table>
<thead>
<tr>
<th style="text-align:left">布局</th>
<th style="text-align:left">路径</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>post</code></td>
<td style="text-align:left"><code>source/_posts</code></td>
</tr>
<tr>
<td style="text-align:left"><code>page</code></td>
<td style="text-align:left"><code>source</code></td>
</tr>
<tr>
<td style="text-align:left"><code>draft</code></td>
<td style="text-align:left"><code>source/_drafts</code></td>
</tr>
</tbody>
</table>
<h4 id="文件名称"><a href="#文件名称" class="headerlink" title="文件名称"></a>文件名称</h4><p>Hexo 默认以标题作为文件名称。<code>_config.yml</code> 文件的 <code>new_post_name</code> 参数支持以下变量。</p>
<table>
<thead>
<tr>
<th style="text-align:left">变量</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>:title</code></td>
<td style="text-align:left">标题（小写，空格将会被替换为短杠）</td>
</tr>
<tr>
<td style="text-align:left"><code>:year</code></td>
<td style="text-align:left">建立的年份，比如, <code>2017</code></td>
</tr>
<tr>
<td style="text-align:left"><code>:month</code></td>
<td style="text-align:left">建立的月份（有前导零），比如， <code>04</code></td>
</tr>
<tr>
<td style="text-align:left"><code>:i_month</code></td>
<td style="text-align:left">建立的月份（无前导零），比如，<code>4</code></td>
</tr>
<tr>
<td style="text-align:left"><code>:day</code></td>
<td style="text-align:left">建立的日期（有前导零），比如，<code>07</code></td>
</tr>
<tr>
<td style="text-align:left"><code>:i_day</code></td>
<td style="text-align:left">建立的日期（无前导零），比如，<code>7</code></td>
</tr>
</tbody>
</table>
<h4 id="草稿"><a href="#草稿" class="headerlink" title="草稿"></a>草稿</h4><p>草稿是一种特殊布局，可以通过 <code>publish</code> 命令将草稿移动到 <code>source/_posts</code> 文件夹，也可以在命令中指定 <code>layout</code> 来指定布局。</p>
<pre><code>$ hexo publish [layout] &lt;title&gt;
</code></pre><p>草稿默认不会显示在页面中，可以在执行时加上<code>--draft</code>参数，或者是把 <code>render_drafts</code> 参数设为 <code>true</code> 来预览草稿。</p>
<h4 id="模板（Scaffold）"><a href="#模板（Scaffold）" class="headerlink" title="模板（Scaffold）"></a>模板（Scaffold）</h4><p>在新建文章时，Hexo 会根据 <code>scaffolds</code>文件夹内相对应的文件来建立文件，例如：</p>
<pre><code>$ hexo new photo &quot;My Gallery&quot;
</code></pre><p>在执行这行命令时，Hexo 会尝试在 <code>scaffolds</code> 文件夹中寻找 <code>photo.md</code>，并根据其内容建立文章，以下是您可以在模版中使用的变量：</p>
<table>
<thead>
<tr>
<th style="text-align:left">变量</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>layout</code></td>
<td style="text-align:left">布局</td>
</tr>
<tr>
<td style="text-align:left"><code>title</code></td>
<td style="text-align:left">标题</td>
</tr>
<tr>
<td style="text-align:left"><code>date</code></td>
<td style="text-align:left">文件建立日期</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h3><p>Front-matter 是文件最上方以 <code>---</code> 分隔的区域，用于指定个别文件的变量。以下是预先定义的参数，您可以在模板中使用这些参数值并加以利用。</p>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>layout</code></td>
<td style="text-align:left">布局</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>title</code></td>
<td style="text-align:left">标题</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>date</code></td>
<td style="text-align:left">建立日期</td>
<td style="text-align:left">文件建立日期</td>
</tr>
<tr>
<td style="text-align:left"><code>updated</code></td>
<td style="text-align:left">更新日期</td>
<td style="text-align:left">文件更新日期</td>
</tr>
<tr>
<td style="text-align:left"><code>comments</code></td>
<td style="text-align:left">开启文章的评论功能</td>
<td style="text-align:left">true</td>
</tr>
<tr>
<td style="text-align:left"><code>tags</code></td>
<td style="text-align:left">标签（不适用于分页）</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>categories</code></td>
<td style="text-align:left">分类（不适用于分页）</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>pwemLINK</code></td>
<td style="text-align:left">覆盖文章网址</td>
</tr>
</tbody>
</table>
<p>如果希望文章不可见，可以将 <code>layout</code> 变量设置为 <code>false</code>。</p>
<h4 id="分类和标签"><a href="#分类和标签" class="headerlink" title="分类和标签"></a>分类和标签</h4><p>只有文章支持分类和标签，你可以在 Front-matter 中设置。在 Hexo 中分类和标签有着明显的差别：分类具有顺序性和层次性，而标签则相反。另外，Hexo 不支持多个同级的分类。例如：</p>
<pre><code>categories:
    - Tools
    - Git
tags:
    - Git
    - Github
    - CVS
</code></pre><p>以上设置中，会使 <code>Git</code> 分类成为 <code>Tools</code> 的子分类，而不是并列分类。</p>
<h4 id="JSON-Front-matter"><a href="#JSON-Front-matter" class="headerlink" title="JSON Front-matter"></a>JSON Front-matter</h4><p>除了 YAML 之外，也可以使用 JSON 来编写 Front-matter，只要将 <code>---</code> 替换为 <code>;;;</code> 即可。</p>
<hr>
<h3 id="标签插件"><a href="#标签插件" class="headerlink" title="标签插件"></a>标签插件</h3><p>标签插件和 Front-matter 中的标签不同，这综合症是用于在文章中快速插入特定内容的插件。</p>
<h4 id="引用块"><a href="#引用块" class="headerlink" title="引用块"></a>引用块</h4><p>在文章中插入引言，可包含作者，来源和标题。</p>
<pre><code>{% blockquote [author[, source]] [link] [source_link_title] %}
    content
    {% endblockquote %}
</code></pre><p>例如，引用书上的句子：</p>
<blockquote><p>Do not just seek happiness for yourself. Seek happiness for all. Through mercy.</p>
<footer><strong>David Levithan</strong><cite>Wide Awake</cite></footer></blockquote>
<h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><p>在文章中插入代码。</p>
<pre><code>{% codeblock [title] [lang:language] [url] [link text] %}
    code snippet
    {% endcodeblock %}
</code></pre><h4 id="反引号代码块"><a href="#反引号代码块" class="headerlink" title="反引号代码块"></a>反引号代码块</h4><p>另一种形式的代码块，不同的是它使用三个反引号来包裹。</p>
<pre><code>``` [language] [title] [url] [link text] code snippet ```
</code></pre><h4 id="Pull-Quote"><a href="#Pull-Quote" class="headerlink" title="Pull Quote"></a>Pull Quote</h4><p>在文章中插入 Pull Quote。</p>
<pre><code>{% pullquote [class] %}
    content
    {% endpullquote %}
</code></pre><h4 id="jsFiddle"><a href="#jsFiddle" class="headerlink" title="jsFiddle"></a>jsFiddle</h4><p>在文章中嵌入 jsFiddle。</p>
<pre><code>{% jsfiddle shorttag [tabs] [skin] [width] [height] %}
</code></pre><h4 id="Gist"><a href="#Gist" class="headerlink" title="Gist"></a>Gist</h4><p>在文章中嵌入 Gist。</p>
<pre><code>{% gist gist_id [filename] %}
</code></pre><h4 id="iframe"><a href="#iframe" class="headerlink" title="iframe"></a>iframe</h4><p>在文章中插入 iframe。</p>
<pre><code>｛% iframe url [width] [height] %｝
</code></pre><h4 id="image"><a href="#image" class="headerlink" title="image"></a>image</h4><p>在文章中插入指定大小的图片。</p>
<pre><code>{% img [class names] /path/to/image [width] [height] [title text [alt text]] %}
</code></pre><h4 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h4><p>在文章中插入链接，并自动给外部链接添加 <code>target=&quot;_blank&quot;</code> 属性。</p>
<pre><code>{% link text url [external] [title] %}
</code></pre><h4 id="Include-Code"><a href="#Include-Code" class="headerlink" title="Include Code"></a>Include Code</h4><p>插入 <code>source</code> 文件夹内的代码文件。</p>
<pre><code>{% include_code [title] [lang:language] path/to/file %}
</code></pre><h4 id="Youtube"><a href="#Youtube" class="headerlink" title="Youtube"></a>Youtube</h4><p>在文章中插入 Youtube 视频。</p>
<pre><code>{% youtube video_id %}
</code></pre><h4 id="Vimeo"><a href="#Vimeo" class="headerlink" title="Vimeo"></a>Vimeo</h4><p>在文章中插入 Vimeo 视频。</p>
<pre><code>{% vimeo video_id %}
</code></pre><h4 id="引用文章"><a href="#引用文章" class="headerlink" title="引用文章"></a>引用文章</h4><p>引用其它文章的链接。</p>
<pre><code>{% post_path slug %}
{% post_link slug [title] %}
</code></pre><h4 id="引用资源"><a href="#引用资源" class="headerlink" title="引用资源"></a>引用资源</h4><p>引用文章的资源。</p>
<pre><code>{% asset_path slug %}
{% asset_img slug [title] %}
{% asset_link slug [title] %}
</code></pre><h4 id="Raw"><a href="#Raw" class="headerlink" title="Raw"></a>Raw</h4><p>如果您想在文章中插入 Swig 标签，可以尝试使用 Raw 标签，以免发生解析异常。</p>
<pre><code>{% raw %}
    content
    {% endraw %}
</code></pre><hr>
<h3 id="资源文件夹"><a href="#资源文件夹" class="headerlink" title="资源文件夹"></a>资源文件夹</h3><p>资源（Asset）代表 <code>source</code> 文件夹中除了文章以外的所有文件。访问它们的最简单方法是使用相对路径的常规 markdown 语法<code>![](/xxx/xxx.jpg)</code>。但该方法不能在首页上正确工作。</p>
<h4 id="文章资源文件夹"><a href="#文章资源文件夹" class="headerlink" title="文章资源文件夹"></a>文章资源文件夹</h4><p>如果想单独组织和管理各个文章的资源，可以将<code>_config.yml</code>的<code>post_asset_folder</code>的选项设为<code>true</code>。Hexo会在每次通过<code>hexo new [layout] &lt;title&gt;</code>命令创建新文章时自动创建一个与 markdown 文件一样名字的文件夹，可以将所有与该文章有关的资源放到这个关联文件夹中，就可以通过相对路径来引用它们。方法参考<a href="#引用资源">引用资源</a>。</p>
<p>例如：</p>
<pre><code>{% asset_img example.jpg This is an example image. %}
</code></pre><hr>
<h3 id="数据文件"><a href="#数据文件" class="headerlink" title="数据文件"></a>数据文件</h3><p>如果您需要在主题中使用某些资源，而这些资料并不会在文章内，并且是需要重复使用的，那么可以考虑 数据文件 功能。此功能会载入 <code>source/_data</code> 内的 YAML 或 JSON 文件。</p>
<p>举例来说，在 <code>source/_data</code> 文件夹中新建 <code>menu.yml</code> 文件：</p>
<pre><code>Home: /
Gallery: /gallery/
Archives: /archives/
</code></pre><p>就可以在模板中使用：</p>
<pre><code>&lt;% for (var link in site.data.menu) { %&gt;
&lt;% &lt;a href=&quot;&lt;%= site.data.menu[link]  %&gt;&quot;&gt; &lt;%= link %&gt; &lt;/a&gt; %&gt;
&lt;% } %&gt;
</code></pre><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>在开始之前，您必须先在 <code>_config.yml</code>中修改参数，一个正确的部署配置中至少要有 <code>type</code> 参数，例如：</p>
<pre><code>deploy:
    type: git
</code></pre><p>您可以同时使用多个 deployer，Hexo 会依照顺序执行每个 deployer。</p>
<pre><code>deploy:
- type: git
  repo:
- type: heroku
  repo:
</code></pre><h4 id="部署到-Git"><a href="#部署到-Git" class="headerlink" title="部署到 Git"></a>部署到 Git</h4><p>安装 <code>hexo-deployer-git</code>。</p>
<pre><code>$ npm install hexo-deployer-git --save
</code></pre><p>修改配置：</p>
<pre><code>deploy:
  type:git
  repo: &lt;repository url&gt;
  branch: [branch]
  message: [message]
</code></pre><table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>repo</code></td>
<td style="text-align:left">库（Repository）地址。</td>
</tr>
<tr>
<td style="text-align:left"><code>branch</code></td>
<td style="text-align:left">分支名称。</td>
</tr>
<tr>
<td style="text-align:left"><code>message</code></td>
<td style="text-align:left">自定义提交信息。</td>
</tr>
</tbody>
</table>
<p>其它部署类型请参考<a href="https://hexo.io/zh-cn/docs/deployment.html" target="_blank" rel="external">此处</a></p>
]]></content>
      
        <categories>
            
            <category> Hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 使用教程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[新的开始]]></title>
      <url>http://blog.zhiyuanep.net/2017/03/27/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/</url>
      <content type="html"><![CDATA[<p>这是一个新的开始。</p>
]]></content>
      
        
    </entry>
    
  
  
</search>
